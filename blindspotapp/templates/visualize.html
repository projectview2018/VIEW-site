{% extends "base.html" %}
{% load static %}
{% block content %}
<link rel="stylesheet" type="text/css" href="{% static 'blindspotapp/home.css' %}">
<html>
{% include 'header.html' %}
<div id=top_text>
    <h3 style="text-align:center;font-weight:bold;">Direct Vision Comparison Tool
    <div class="container">
        <h5>The plot below displays vehicle entries grouped by body class, which are
        also reflected in the table below. The plot and table will update based on inputs to the search bar and the range filter.
        Hover over individual points on the plot to find more information about that particular vehicle.
        </h5>
    </div>
</div>
<meta charset="utf-8">

<!-- Load d3.js and plugin for color scale -->
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

<div class="container">
    <label>Y-Axis Variable</label>
    <select id="yButton" onchange = changeDependent()>
        <option selected value="Overall Visibility">Overall Visibility</option>
        <option value="Front Visibility">Front Visibility</option>
        <option value="Side Visibility">Side Visibility</option>
    </select>

    <div style="text-align: center">
        <button class="btn btn-primary" id="duplicateButton" onclick = toggleDuplicates()>Add/Remove Duplicate Entries</button>
    </div>
</div>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz" align="center"></div>

<br>
<div class="container">
    <h5 style="text-align:center;">By default, the table is sorted by overall visibility in decreasing order. Use the search bar to filter by any metric,
    and use the range slider to filter by percentile rank. Each vehicle's percentile rank is calculated relative to all other vehicles in the same
    body class. You can also click on the column name to sort by that variable as well.
    </h5>
</div>

<!-- Datatables library, makes HTML table filterable -->
<link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.10.25/css/jquery.dataTables.css">
<script type="text/javascript" charset="utf8" src="https://cdn.datatables.net/1.10.25/js/jquery.dataTables.js"></script>

<div class="margintable">
    <p>
        <label for="amount">Overall Visibility Percentile Range:</label>
        <input type="text" id="amount" readonly style="border:0; color:#2196F3; font-weight:bold;">
    </p>
    <div id="slider-range"></div>
    <!-- scripts for the slider -->
    <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <!-- script below initializes the slider, sets values, and defines what happens when slider changes -->
    <script>
    $( function() {
        $( "#slider-range" ).slider({
        range: true,
        min: 0,
        max: 100,
        values: [ 0, 100 ],
        step: 10,
        slide: function( event, ui ) {
            $( "#amount" ).val( ui.values[ 0 ] + "th - " + ui.values[ 1 ] + "th Percentile");
        },
        change: function( event, ui ) {
            rangeSearch(ui);
            var table = $('#my_table').DataTable();
            table.draw();
        }
        });
        $( "#amount" ).val( $( "#slider-range" ).slider( "values", 0 ) +
        "th - " + $( "#slider-range" ).slider( "values", 1 ) + "th Percentile" );
        // referenced from stack overflow and http://jsfiddle.net/6zqFq/305/
        for (var i = 0; i <= 10; i++) {
            var el = $('<label>' + (0 + 10 * i) + '</label>').css({'left': (i/10*100) + '%', "position" : "absolute", "width" : "20px", "margin-top" : "15px", "margin-left" : "-10px", "text-align": "center"});
            $("#slider-range").append(el);
        }
    } );
    </script>

    <br>
    <br>
    <!-- Create a div where the table will take place -->
    <table id="my_table" class="display" align="center"></table>
</div>

<div class="container">
    <br>
	<div class="accordion accordion-flush" id="accordionExample">
		<div class="accordion-item"  style = "border: 1px solid #dddddd;">
			<h2 class="accordion-header" id="headingvisualizefaq">
				<button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#visualizefaq" aria-expanded="false" aria-controls="visualizefaq" id = "button_text">
				Frequently Asked Questions
				</button>
			</h2>
			<div id="visualizefaq" class="accordion-collapse collapse" aria-labelledby="heading">
				<div class="accordion-body">
					<div class="accordion accordion-flush" id="accordionExample">
						{% include 'faq_visualize.html' %}
					</div>
				</div>
			</div>
		</div>
	</div>

  <hr>
  <h4 style="font-style:italic;font-size:13px;">This document is funded by the Santos Family Foundation and disseminated under the
    sponsorship of the Department of Transportation in the interest of information exchange. The United States
    Government assumes no liability for the contents or use thereof. The United States Government does not
    endorse products, manufacturers, or state or local policies or laws unless specifically indicated. Trade or
    manufacturersâ€™ names may appear herein solely because they are considered essential to the objective of this
    document. Site contents represent the best technical judgement of U.S. DOT Volpe Center staff based on their
    independent and objective technical analysis and expertise, and are not to be misconstrued as statements of
    U.S. DOT policy or guidance.
  </h4>
</div>

</html>

<script type="text/javascript">
    // global data variable
    var data;
    // global median/grouped_data variable
    var median_data;
    // boolean that toggles each time the toggle duplicate button is pushed
    var toggle = false;

    // variable displayed on y-axis; default is "Overall Visibility"
    var variable = "Overall Visibility";

    // creates datatable, detects when search is active and updates violin plot accordingly
    function prepareDataTable() {
        $(document).ready(function() {
            var table = $('#my_table').DataTable( {
                "order": [0, 'desc'],
                "paging": true,
                "processing": true
            } );

            // this is executed whenever a search/filter is active
            table.on( 'search.dt', function () {
                var table_data = table.rows( {search:'applied'} ).data();
                //console.log(table_data);
                var filtered_table_data = [];

                // gets the actual data, removes filler info
                for (i = 0; i < table_data.length; i ++) {
                    filtered_table_data.push(table_data[i])
                    console.log(filtered_table_data);
                }

                // turns each vehicle entry into dictionary
                dictionary = Object.assign({}, filtered_table_data.map((x) => ({"Overall Visibility": parseInt(x[0]), "Front Visibility": parseInt(x[1]),
                "Side Visibility": parseInt(x[2]), "Percentile": x[3], "Make": x[4], "Model": x[5], "Year": x[6], "Body Class": x[7]})));
                //console.log(typeof(dictionary))
                final_var = []

                // appends [] around all the vehicle entries to create correct format
                for (i = 0; i < filtered_table_data.length; i++) {
                    final_var.push(dictionary[i])
                }
                console.log(final_var)
                data = final_var // data variable should reflect filtered data
                reset_violin()
                makeViolin(final_var, variable)
            });
        } );
    }

    // filters data based on slider, or overall visibility
    function rangeSearch(ui) {
        console.log(ui.values)
        $.fn.dataTable.ext.search.pop()
        $.fn.dataTable.ext.search.push(
        function( settings, data, dataIndex ) {
            var min = parseInt( ui.values[0], 10 );
            var max = parseInt( ui.values[1], 10 );
            console.log(min, max)
            console.log(data)
            var age = parseFloat( data[3] ) || 0; // data[3] corresponds to percentile, data[0] corresponds to overall visibility

            if ( ( isNaN( min ) && isNaN( max ) ) ||
                ( isNaN( min ) && age <= max ) ||
                ( min <= age   && isNaN( max ) ) ||
                ( min <= age   && age <= max ) )
            {
                return true;
            }
            return false;
        }
    );
    }

    // retrieves Airtable data from getddata method in views.py
    let request = new XMLHttpRequest();
	let url = "/api/v1/getddata/"; //this causes the POST
	request.responseType = "json";
	var headers = { 'content-type': 'application/json' };
	request.onload = function () {
		let response = this.response;

        // data is an array where each element is [percent visible, front visibility, side visibility, make, model, year, weight class]
        console.log(response)
		data = response['data'];
        //median_data = response['data'][(response['index'] + 1):];
        console.log(median_data)
      //  tabulate(data, ["Overall Visibility", "Front Visibility", "Side Visibility", "Percentile", "Make", "Model", "Year", "Body Class",
      //  "Weight Class", "Image", "Front", "Side", "Overhead", "ID"]);
      //  tabulate(data, ["Date Added", "Overall Visibility", "Front Visibility", "Side Visibility", "Percentile", "Make", "Model", "Year", "Body Class",
      //  "Weight Class", "Image", "ID"]);
        tabulate(data, ["Date Added", "Overall Visibility", "Front Visibility", "Side Visibility", "Percentile", "Make", "Model", "Year", "Body Class",
        "Weight Class", "ID"]);
        prepareDataTable();
		makeViolin(data, variable);
	}
    request.open("POST", url);
	request.send(body = JSON.stringify({'weight': '0'}));

    // retrieves grouped_data and stores it in median_data, similar process as above
    let request_2 = new XMLHttpRequest();
	let url_2 = "/api/v1/getunduplicateddata/"; //this causes the POST
	request_2.responseType = "json";
	var headers = { 'content-type': 'application/json' };
	request_2.onload = function () {
		let response = this.response;
		median_data = response['grouped_data'];
	}
    request_2.open("POST", url_2);
	request_2.send(body = JSON.stringify({'weight': '0'}));


    // creates the violin plot, variable is the y-axis variable that'll be displayed
    // some of the comments are taken from https://www.d3-graph-gallery.com/graph/violin_jitter.html
    function makeViolin(data, variable) {
        // set the dimensions and margins of the graph
        var margin = {top: 10, right: 30, bottom: 30, left: 70},
            width = 1200 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        var svg = d3.select("#my_dataviz")
        .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom + 20)
        .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");

        // color scale: one color for each group
        var myColor = d3.scaleOrdinal()

        // build and show the y scale
        var y = d3.scaleLinear()
            .domain([ 0, 100 ]) // y scale is set manually
            .range([height, 0])
        svg.append("g").call( d3.axisLeft(y) )

        // build and show the x scale
        // this is a band scale like for a boxplot; each group has a dedicated range on the axis, where range has length of x.bandwidth
        var x = d3.scaleBand()
            .range([ 0, width ])
            //.domain(["N/A", "Class 1", "Class 2", "Class 3", "Class 4", "Class 5", "Class 6", "Class 7", "Class 8"])
            .domain(["N/A", "Passenger", "SUV", "Minivan", "Van", "Pickup Truck", "Commercial Truck", "Bus"]) // use this to change/remove plot categories on x-axis
            .padding(0) // this is the space between 2 groups; 0 is no padding, 1 is the max
        svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x))

        // features of the histogram
        var histogram = d3.histogram()
                .domain(y.domain())
                .thresholds(y.ticks(20)) // important: how many bins approx are going to be made? it is the 'resolution' of the violin plot
                .value(d => d)

        // compute the binning for each group of the dataset
        var sumstat = d3.nest() // nest function allows to group the calculation per level of a factor
            .key(function(d) { return d['Body Class'];})
            .rollup(function(d) {   // For each key..
            input = d.map(function(g) { return g[variable];}) // Keep the variable called Sepal_Length
            bins = histogram(input) // And compute the binning on it.
            return(bins)
            })
            .entries(data)

        // What is the biggest number of value in a bin? We need it cause this value will have a width of 100% of the bandwidth.
        var maxNum = 0
        for ( i in sumstat ){
            allBins = sumstat[i].value
            lengths = allBins.map(function(a){return a.length;})
            longuest = d3.max(lengths)
            if (longuest > maxNum) { maxNum = longuest }
        }

        // The maximum width of a violin must be x.bandwidth = the width dedicated to a group
        var xNum = d3.scaleLinear()
            .range([0, x.bandwidth() + 20])
            .domain([-maxNum,maxNum])

        // color scale for dots
        var myColor = d3.scaleSequential()
            .interpolator(d3.interpolateInferno)
            .domain([0,100])

        // add the shape to this svg
        svg
            .selectAll("myViolin")
            .data(sumstat)
            .enter() // So now we are working group per group
            .append("g")
            .attr("transform", function(d){ return("translate(" + x(d.key) +" ,0)") } ) // Translation on the right to be at the group position
            .append("path")
                .datum(function(d){ return(d.value)}) // So now we are working bin per bin
                .style("stroke", "none")
                .style("fill","grey")
                .attr("d", d3.area()
                    .x0( xNum(0) )
                    .x1(function(d){ return(xNum(d.length)) } )
                    .y(function(d){ return(y(d.x0)) } )
                    .curve(d3.curveStep)
                )

        // A function that change this tooltip when the user hover a point.
        // Its opacity is set to 1: we can now see it. Plus it set the text and position of tooltip depending on the datapoint (d)
        var mouseover = function(d) {
            tooltip
                .transition()
                .duration(200)
                .style("opacity", 1)

            tooltip
                .transition()
                .duration(200)
                .style("opacity", 1)
            tooltip
                .html("Make: " + d['Make'] + "<br>Model: " + d['Model'] + "<br>Year: " + d['Year'] + "<br>Body: " + d['Body Class'] + "<br>Overall: " + d['Overall Visibility']
                + "%<br>Front: " + d['Front Visibility'] + "%<br>Side: " + d['Side Visibility'] + "%<br>Percentile: " + d['Percentile'])
                .style("left", (d3.mouse(this)[0]) + 300 + "px")
                .style("top", (d3.mouse(this)[1]) + 300 + "px")
            }

        var mousemove = function(d) {
            tooltip
                .html("Make: " + d['Make'] + "<br>Model: " + d['Model'] + "<br>Year: " + d['Year'] + "<br>Body: " + d['Body Class'] + "<br>Overall: " + d['Overall Visibility']
                + "%<br>Front: " + d['Front Visibility'] + "%<br>Side: " + d['Side Visibility'] + "%<br>Percentile: " + d['Percentile'])
                .style("left", (d3.mouse(this)[0]) + 300 + "px")
                .style("top", (d3.mouse(this)[1]) + 300 + "px")
        }

        // A function that change this tooltip when the leaves a point: just need to set opacity to 0 again
        var mouseleave = function(d) {
            tooltip
                .transition()
                .duration(200)
                .style("opacity", 0)
        }

        var tooltip = d3.select("#my_dataviz")
			.append("div")
			.style("opacity", 0)
            .attr("class", "tooltip")
            .style("background-color", "white")
            .style("border", "solid")
            .style("border-width", "1px")
            .style("border-radius", "5px")
            .style("padding", "10px")

        // Add individual points with jitter
        var jitterWidth = 60
        svg
            .selectAll("indPoints")
            .data(data)
            .enter()
            .append("circle")
            .attr("cx", function(d){return(x(d['Body Class']) + x.bandwidth()/2 - Math.random() * jitterWidth)})
            .attr("cy", function(d){
                // prevents NaN error (eg: if an entry doesn't have a front/side visibility score, place it at y = 0)
                return y(d[variable])
            })
            .attr("r", 5)
            .style("fill", function(d){
                if (d[variable] == "N/A") {
                    return myColor(0)
                }
                else {
                    return myColor(d[variable])
                }
            })
            .attr("stroke", "white")
            .on("mouseover", mouseover)
			.on("mousemove", mousemove)
			.on("mouseleave", mouseleave)

        // add x axis label
        svg
            .append("text")
            .style("font-size", "14px")
            .attr("class", "x label")
            .attr("text-anchor", "end")
            .attr("x", width)
            .attr("y", height + 40)
            .text("Body Class");

        // add y axis label
        svg
            .append("text")
            .style("font-size", "14px")
            .attr("class", "y label")
            .attr("text-anchor", "end")
            .attr("y", -50)
            .attr("dy", ".75em")
            .attr("transform", "rotate(-90)")
            .text(variable + " (%)");

        /**
        // zoom capability for violin plot, might be added in the future
        var zoom = d3.zoom()
            .scaleExtent([.5, 20])
            .extent([[0, 0], [width, height]])
            .on("zoom", updateChart);

        svg.append("rect")
            .attr("width", width)
            .attr("height", height)
            .style("fill", "none")
            .style("pointer-events", "all")
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
            .call(zoom);

        function updateChart() {
            // recover the new scale
            var newX = d3.event.transform.rescaleX(x);
            var newY = d3.event.transform.rescaleY(y);

            // update axes with these new boundaries
            xAxis.call(d3.axisBottom(newX))
            yAxis.call(d3.axisLeft(newY))

            // update circle position
            svg
            .selectAll("indPoints")
            .attr('cx', function(d) {return newX(d['Weight Class'])})
            .attr('cy', function(d) {return newY(d['Percent Visible'])});
        }
        **/
    }

    // generates table with data
    function tabulate(data, columns) {
        //console.log(data);
        //console.log(columns);

        var table = d3.select("#my_table")
            thead = table.append("thead"),
            tbody = table.append("tbody");

        // append the header row
        thead.append("tr")
            .selectAll("th")
            .data(columns)
            .enter()
            .append("th")
                .text(function(column) { return column; });

        // create a row for each object in the data
        var rows = tbody.selectAll("tr")
            .data(data)
            .enter()
            .append("tr");

        // create a cell in each row for each column
        var cells = rows.selectAll("td")
            .data(function(row) {
                return columns.map(function(column) {
                    return {column: column, value: row[column]};
                });
            })
            .enter()
            .append("td")
            .html(function(d) {
                // if the cell is an image and the value is a nonempty string with "cloudinary" in it, add embedded URL link
                if (d.value != "" && (d.column == "Image" || d.column == "Front" || d.column == "Side" || d.column == "Overhead")) {
                    var url = d.value;
                    if (url == null) {
                        return
                    }
                    else if (url.includes("cloudinary")) {
                        return "<a href="+ d.value + " target=_blank" + ">" + "<img src=" + d.value + ">" + "</a>"
                    }
                }
                // if it's an ID/Info cell, add an embedded URL link
                else if (d.column == "ID") {
                    var url = "getinfo/" + d.value
                    return "<a href="+ url + " target=_blank" + ">" + "Details" + "</a>"
                }

                // if the cell's value is a number, make it a percentage
                else if (typeof(d.value) == "number" && d.column != "Percentile") {
                    return d.value + "%"
                }
                // if the cell is neither of the above, just add the value
                else {
                    return d.value
                }
            });
    }

    // clears just the violin plot
    function reset_violin() {
        $("#my_dataviz").empty();
    }

    function reset_table() {
        $("#my_table").empty();
    }

    // changes the y-axis variable
    function changeDependent() {
        variable = document.getElementById("yButton").value;
        reset_violin();
        makeViolin(data, variable);
    }

    // toggles duplicate entries
    function toggleDuplicates() {
        reset_violin();
        //reset_table();

        if (toggle == false) {
            //$('#my_table').DataTable().clear();
            //$.fn.dataTable.tables().clear()

            //tabulate(median_data, ["Overall Visibility", "Front Visibility", "Side Visibility", "Percentile", "Make", "Model", "Year", "Body Class",
            //"Weight Class", "Image", "Front", "Side", "Overhead", "ID"]);
            //prepareDataTable();
            makeViolin(median_data, variable);
            toggle = true;
        }

        else {
            //$('#my_table').DataTable().clear();

            //tabulate(data, ["Overall Visibility", "Front Visibility", "Side Visibility", "Percentile", "Make", "Model", "Year", "Body Class",
            //"Weight Class", "Image", "Front", "Side", "Overhead", "ID"]);
            //prepareDataTable();
            makeViolin(data, variable);
            toggle = false;
        }
    }
</script>
{% endblock %}
